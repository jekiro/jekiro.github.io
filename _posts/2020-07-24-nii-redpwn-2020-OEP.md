---
layout: single
title: "redpwn-2020 nii writeup"
header:
  teaser:
excerpt: "Nii was a reverse engineering challenge in the redpwn 2020 CTF that required implementing a CRC algorithim after reversing assembly."
---

### Challenge Information

Challenge: wintendo-nii  
Created by: imyxh  
Files: [nii](/assets/files/nii)
>Someone gave me this weird knockoff game console and I think it's hiding a flag. I managed to dump the firmware and host it on this server; can you take it from here?  
>nc 2020.redpwnc.tf 31215

## Basic Research

Beginning basic analysis on the program, running file shows that it's a `64 bit executable ELF`.

>nii: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, BuildID[sha1]=8def7e412da3017e4dd7fcf2c2d6ad0ac37ba8e4, stripped

The binary is statically linked and stripped, which would make sense because the binary is firmware. And running it, it prints some Chinese and takes user input but closes right after.

![](/content/OEP/nii/run.PNG)

Translating the Chinese to English shows that it is:

```
In 2020, Wentian Software Company-All rights reserved.
Please insert the game disk...
```

So a first guess is that the binary is reading some sort of code for a "game disk" through stdin.

## Static Analysis

With the assumptions from basic research on the binary, we step into a disassembler which my choice was `IDA`.

![](/content/OEP/nii/start.PNG)

The binary is small and uses syscalls, but something is stopping IDA from defining a function for `start`. Trying to define a function at the beginning of `start` by pressing `P` while selecting the first instruction puts the failure output in the console.

```
.text:0000000000401205: The function has undefined instruction/data at the specified address.
```

Quickly scanning `start` for the undefined instructions, the binary calls `sys_write`, `sys_mmap`, and `sys_read`. It then has small function calls and compares to large integers moved into `rax`. Then a looping block of code, a call to `sys_mprotect`, and a call to `sys_exit`. The call to `sys_exit` doesn't seem to have a conditional to go around it so the data after is most likely what is causing the errors. Undefining the data from instructions makes it pretty obvious that it is a string for 
```
int main() {
    puts(flag);
}
```

![](/content/OEP/nii/dataend.PNG)

To fix this, go to the end of the function which in this case is the syscall to `sys_exit` at `0x11F1` in the binary. Press `Alt+L`, go back up to the beginning of `start`, click the beginning of start at `0x1025` and press `P` to define a function. This defines an anchor point in IDA which allows it to understand that you're manually defining the end of a function rather than IDA assuming it incorrectly, which happens when embedded data is in code.  

Now that graph view is accessible, the code flow is a lot more obvious. We'll look at the binary block by block in graph view.  

![](/content/OEP/nii/node1.PNG)

The first code block has a call to `sys_write` which writes out the Chinese text to stdout. The binary then maps a `0x1000` sized memory region with `sys_mmap`. After mapping the region it reads from `stdin` into a buffer at `0x402064` with the size `0x200`. The resulting value from `sys_read` which is the amount of bytes read gets divided by 2 and moved into `0x402062`.  

![](/content/OEP/nii/node2.PNG)

The second code block is a loop with the iterator in the `rcx` register. It moves the byte at `[rsi+rcx*2]` into `al`, which is the lower 8 bits of `rax`. It then calls the function `sub_401010` which is seen below in text.

```assembly
.text:0000000000401010 sub_401010      proc near               ; CODE XREF: start+8B↓p
.text:0000000000401010                                         ; start+98↓p
.text:0000000000401010                 cmp     al, 30h
.text:0000000000401012                 jl      short sub_401000
.text:0000000000401014                 cmp     al, 39h
.text:0000000000401016                 jle     short loc_401022
.text:0000000000401018                 cmp     al, 41h
.text:000000000040101A                 jl      short sub_401000
.text:000000000040101C                 cmp     al, 46h
.text:000000000040101E                 jg      short sub_401000
.text:0000000000401020                 sub     al, 7
.text:0000000000401022
.text:0000000000401022 loc_401022:                             ; CODE XREF: sub_401010+6↑j
.text:0000000000401022                 sub     al, 30h
.text:0000000000401024                 retn
.text:0000000000401024 sub_401010      endp
```

This function compares `al` from the code calling it, which in the case of the first run of the function, will be the first character we sent. Just as an example, we will use `A` or `0x41`. Going through the function while assuming `al` is `0x41`, we get through all the checks. The calls to `sub_401000` are basically just exiting the program as `sub_401000` is just a syscall to `sys_exit`, so I renamed it to `exit`. The function's code flow with `0x41` subtracts 7 from it, which would be `0x3A`, and subtracted by `0x30` would be `0xA`. So the function at `sub_401010` translates a single hex ASCII character into it's hex value.  

Looking after the call to `sub_401010` in the second code block, it shifts `ax` by `0xC` which would make `0xA` in `al` be `0xA000` in `ax`. The code block then retrieves the second character and translates it to it's hex value. The hex value stored in `al` is then added with `ah` to create a single hex value from the hex ASCII. A hex value in ASCII of `7A` would transfer to an `ax` value of `700A` with `ah` being `70` and `ax` being `0A`. When these are added it will make a single value of `7A`. The value of `7A` is then moved into the buffer it was retrieved from and the loop continues until all bytes are translated. From this information we know that the binary expects the ASCII representation of hex for bytes sent to the binary.

![](/content/OEP/nii/node3.PNG)

The third code block is multiple blocks doing repeated checks that IDA separates due to their conditional jumps. The values moved into `rax` are quite obviously ASCII as they are all within the range of readable characters. Change them into strings by clicking on them and pressing `R`. After doing this, the text representation of the graph is below.

```assembly
.text:00000000004010CF                 mov     rax, ':1.0vIIN'
.text:00000000004010D9                 cmp     [rsi], rax
.text:00000000004010DC                 jnz     exit
.text:00000000004010E2                 mov     rax, 'cnrPtlwT'
.text:00000000004010EC                 cmp     [rsi+8], rax
.text:00000000004010F0                 jz      short loc_401127
.text:00000000004010F2                 mov     rax, 'traCoraM'
.text:00000000004010FC                 cmp     [rsi+8], rax
.text:0000000000401100                 jz      short loc_401127
.text:0000000000401102                 mov     rax, '++sentiF'
.text:000000000040110C                 cmp     [rsi+8], rax
.text:0000000000401110                 jz      short loc_401127
.text:0000000000401112                 mov     rax, 'gniXlnmA'
.text:000000000040111C                 cmp     [rsi+8], rax
.text:0000000000401120                 jz      short loc_401127
.text:0000000000401122                 jmp     exit
.text:0000000000401127 ; ---------------------------------------------------------------------------
.text:0000000000401127
.text:0000000000401127 loc_401127:                             ; CODE XREF: start+CB↑j
.text:0000000000401127                                         ; start+DB↑j ...
.text:0000000000401127                 xor     rbx, rbx
```

The first check compares the very first bytes to a string `NIIv0.1:` and if it is not the correct string, jumps to exit. The other checks check for a string after the `:` in the previous check, for different strings that are quite obviously 8 byte version of game names such as `MaroCart`. From this information we can assume the binary is expecting a header of `NIIv0.1:MaroCart` where MaroCart is any name whitelisted in the above check.

## Implementing the CRC algorithim 



![](/content/OEP/nii/flag.PNG)