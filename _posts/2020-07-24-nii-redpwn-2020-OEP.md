---
layout: single
title: "redpwn-2020 nii writeup"
header:
  teaser:
excerpt: "Nii was a reverse engineering challenge in the redpwn 2020 CTF that required implementing a CRC algorithim after reversing assembly."
---

### Challenge Information

Challenge: wintendo-nii  
Created by: imyxh  
Files: [nii](/assets/files/nii)
>Someone gave me this weird knockoff game console and I think it's hiding a flag. I managed to dump the firmware and host it on this server; can you take it from here?  
>nc 2020.redpwnc.tf 31215

## Basic Research

Beginning basic analysis on the program, running file shows that it's a `64 bit executable ELF`.

>nii: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, BuildID[sha1]=8def7e412da3017e4dd7fcf2c2d6ad0ac37ba8e4, stripped

The binary is statically linked and stripped, which would make sense because the binary is firmware. And running it, it prints some Chinese and takes user input but closes right after.

![](/content/OEP/nii/run.PNG)

Translating the Chinese to English shows that it is:

```
In 2020, Wentian Software Company-All rights reserved.
Please insert the game disk...
```

So a first guess is that the binary is reading some sort of code for a "game disk" through stdin.

## Static Analysis

With the assumptions from basic research on the binary, we step into a disassembler which my choice was `IDA`.

![](/content/OEP/nii/start.PNG)

The binary is small and uses syscalls, but something is stopping IDA from defining a function for `start`. Trying to define a function at the beginning of `start` by pressing `P` while selecting the first instruction puts the failure output in the console.

```
.text:0000000000401205: The function has undefined instruction/data at the specified address.
```

Quickly scanning `start` for the undefined instructions, the binary calls `sys_write`, `sys_mmap`, and `sys_read`. It then has small function calls and compares to large integers moved into `rax`. Then a looping block of code, a call to `sys_mprotect`, and a call to `sys_exit`. The call to `sys_exit` doesn't seem to have a conditional to go around it so the data after is most likely what is causing the errors. Undefining the data from instructions makes it pretty obvious that it is a string for 
```
int main() {
    puts(flag);
}
```

![](/content/OEP/nii/dataend.PNG)

To fix this, go to the end of the function which in this case is the syscall to `sys_exit` at `0x11F1` in the binary. Press `Alt+L`, go back up to the beginning of `start`, click the beginning of start at `0x1025` and press `P` to define a function. This defines an anchor point in IDA which allows it to understand that you're manually defining the end of a function rather than IDA assuming it incorrectly, which happens when embedded data is in code.  

Now that graph view is accessible, the code flow is a lot more obvious. We'll look at the binary block by block in graph view.  

![](/content/OEP/nii/node1.PNG)

The first code block has a call to `sys_write` which writes out the Chinese text to stdout. The binary then maps a `0x1000` sized memory region with `sys_mmap`. After mapping the region it reads from `stdin` into a buffer at `0x402064` with the size `0x200`. The resulting value from `sys_read` which is the amount of bytes read gets divided by 2 and moved into `0x402062`.  

![](/content/OEP/nii/node2.PNG)

The second code block is a loop with the iterator in the `rcx` register. It moves the byte at `[rsi+rcx*2]` into `al`, which is the lower 8 bits of `rax`. It then calls the function `sub_401010` which is seen below in text.

```
.text:0000000000401010 sub_401010      proc near               ; CODE XREF: start+8B↓p
.text:0000000000401010                                         ; start+98↓p
.text:0000000000401010                 cmp     al, 30h
.text:0000000000401012                 jl      short sub_401000
.text:0000000000401014                 cmp     al, 39h
.text:0000000000401016                 jle     short loc_401022
.text:0000000000401018                 cmp     al, 41h
.text:000000000040101A                 jl      short sub_401000
.text:000000000040101C                 cmp     al, 46h
.text:000000000040101E                 jg      short sub_401000
.text:0000000000401020                 sub     al, 7
.text:0000000000401022
.text:0000000000401022 loc_401022:                             ; CODE XREF: sub_401010+6↑j
.text:0000000000401022                 sub     al, 30h
.text:0000000000401024                 retn
.text:0000000000401024 sub_401010      endp
```



## Implementing the CRC algorithim 



![](/content/OEP/nii/flag.PNG)