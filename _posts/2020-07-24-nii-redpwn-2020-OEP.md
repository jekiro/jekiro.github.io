---
layout: single
title: "redpwn-2020 nii writeup"
header:
  teaser:
excerpt: "Nii was a reverse engineering challenge in the redpwn 2020 CTF that required implementing a CRC algorithim after reversing assembly."
---

### Challenge Information

Challenge: wintendo-nii  
Created by: imyxh  
Files: [nii](/assets/files/nii)
>Someone gave me this weird knockoff game console and I think it's hiding a flag. I managed to dump the firmware and host it on this server; can you take it from here?  
>nc 2020.redpwnc.tf 31215

## Basic Research

Beginning basic analysis on the program, running file shows that it's a `64 bit executable ELF`.

>nii: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, BuildID[sha1]=8def7e412da3017e4dd7fcf2c2d6ad0ac37ba8e4, stripped

The binary is statically linked and stripped, which would make sense because the binary is firmware. And running it, it prints some Chinese and takes user input but closes right after.

![](/content/OEP/nii/run.PNG)

Translating the Chinese to English shows that it is:

```
In 2020, Wentian Software Company-All rights reserved.
Please insert the game disk...
```

So a first guess is that the binary is reading some sort of code for a "game disk" through stdin.

## Static Analysis

With the assumptions from basic research on the binary, we step into a disassembler which my choice was `IDA`.

![](/content/OEP/nii/start.PNG)

The binary is small and uses syscalls, but something is stopping IDA from defining a function for `start`. Trying to define a function at the beginning of `start` by pressing `P` while selecting the first instruction puts the failure output in the console.

```
.text:0000000000401205: The function has undefined instruction/data at the specified address.
```

Quickly scanning `start` for the undefined instructions, the binary calls `sys_write`, `sys_mmap`, and `sys_read`. It then has small function calls and compares to large integers moved into `rax`. Then a looping block of code, a call to `sys_mprotect`, and a call to `sys_exit`. The call to `sys_exit` doesn't seem to have a conditional to go around it so the data after is most likely what is causing the errors. Undefining the data from instructions makes it pretty obvious that it is a string for 
```
int main() {
    puts(flag);
}
```

![](/content/OEP/nii/dataend.PNG)

To fix this, go to the end of the function which in this case is the syscall to `sys_exit` at `0x11F1` in the binary. Press `Alt+L`, go back up to the beginning of `start`, click the beginning of start at `0x1025` and press `P` to define a function. This defines an anchor point in IDA which allows it to understand that you're manually defining the end of a function rather than IDA assuming it incorrectly which happens when embedded data is in code.

## Implementing the CRC algorithim 



![](/content/OEP/nii/flag.PNG)